# Очередь (`task04-tsqueue`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Часть 1](#часть-1)
    1. [Часть 2](#часть-2)
1. [Подробнее](#подробнее)
    1. [Описание кода](#описание-кода)
    1. [Сторонние зависимости](#сторонние-зависимости)
    1. [Шаги решения](#шаги-решения)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Код](#код)
    1. [Интерфейс](#интерфейс)
    1. [Тесты](#тесты)
    1. [Разумная попытка](#разумная-попытка)
    1. [Блокирующее](#блокирующее)
1. [Сдача задания](#сдача-задания)
    1. [Процесс](#процесс)
    1. [Сроки](#сроки)
    1. [Система оценки](#система-оценки)

## Задание
### Часть 1
Закончите реализацию и тесты для потокобезопасной очереди `threadsafe_queue` в файлах
`src/tsqueue.h`, `src/tsqueue.cpp` и `src/tsqueue_test.cpp`.
Реализация должна использовать примитивы синхронизации из POSIX Threads и
предоставленную очередь из файлов `src/queue.h` и `src/queue.cpp`.

Вам потребуется реализовать все функции, кроме `threadsafe_queue_wait_and_pop`,
заменить все места, помеченные как `TODO` (но не `TODO(2)`,
а также добавить автоматический запуск теста в файл `.travis.yml`
в _корне_ этого репозитория.
Запрещается добавлять новые функции в интерфейс очереди.

### Часть 2
Необходимые инструменты для реализации этой части
будут пройдены только на лекции 05.12.2019, но вы можете
попробовать решить её до этого и убедиться, что не получается.

Реализуйте и протестируйте функцию `threadsafe_queue_wait_and_pop`,
которая реализует атомарное блокирующее ожидание и извлечение элемента
из очереди.

Вам потребуется заменить все места, помеченные как `TODO(2)`,
а также убрать пропуск тестов (`* doctest::skip()`).
При блокирующем ожидании запрещается неограниченно тратить процессорное
время.

## Подробнее
### Описание кода
Все исходные файлы находятся в папке `src/`.
В папке `doctest/` находится библиотека для написания автоматических тестов.

Вам уже дана реализация обычной (не потокобезопасной) очереди в файлах `queue.h` и `queue.cpp`,
а тесты для неё написаны в файле `queue_test.cpp`.
Очередь состоит из opaque-структуры `Queue` и функций `queue_*()`, которые позволяют с ней работать.

В файлах `tsqueue.h`, `tsqueue.cpp` и `tsqueue_test.cpp` написаны заглушки для вашей
потокобезопасной очереди: структура `ThreadsafeQueue` и функции `threadsafe_queue_*()` для работы с ней.
При решении задания следует не реализовывать очередь с нуля, а использовать предоставленную `Queue`.

Обратите внимание, что метод `empty()` в интерфейсе потокобезопасной очереди отсутствует и реализовывать его не надо.
Возвращаемое им значение для многопоточной очереди было бы невозможно разумно использовать:
после возврата значения реальное состояние очереди уже могло быть изменено другим потоком.

### Сторонние зависимости
Этот код собирается при помощи CMake — это система для генерации проектов на C++ для разных компиляторов.
Запустите в этой папке команду `cmake .`, чтобы сгенерировать проект под
компилятор по умолчанию на вашей системе.
Например, под Linux вы на выходе получите `Makefile`, который можно запустить командой `make`,
а под Windows вы наверняка получите ошибку, потому что Visual Studio не поддерживает POSIX Threads
(в этом задании используйте MSYS2/MinGW).

Предоставленные тесты написаны при помощи библиотеки [doctest](https://github.com/onqtam/doctest),
инструкцию к ней вы можете найти [здесь](https://github.com/onqtam/doctest/blob/master/doc/markdown/tutorial.md).
Макрос `CHECK()` при некорректном условии продолжает работу тестов, а макрос `REQUIRE()` при некорректном условии роняет программу.
Лучше использовать `CHECK()`, если только это не приведёт к очевидному undefined behaviour или зависанию тестов.

Вы также можете запустить тесты с флагом `--duration` (например, `queue_test --duration`), чтобы
законченные тесты выводили информацию про себя (тест, который сейчас выполняется, ничего на экран
до окончания не выводит).

### Шаги решения
Для решения части 1 вам требуется выполнить следующие шаги:
1. Добавьте в `.travis.yml` в корне этого репозитория запуск теста `tsqueue_test` после запуска `queue_test` в аналогичном формате.
   Сейчас он там отсутствует, потому что не проходит из-за не до конца выполненного задания.
2. Скомпилируйте проект и проверьте, что `queue_test` отрабатывает без ошибок, т.е. обычная очередь реализована правильно.
3. Прочитайте реализацию обычной очереди в `queue.h`, `queue.cpp` и пример использования в `queue_test.cpp`.
   Убедитесь, что вам понятна каждая строчка.
4. Прочитайте предложенный интерфейс в `tsqueue.h` и пример использование в `tsqueue_test.cpp`.
   Убедитесь, что вам понятна каждая строчка.
5. Реализуйте необходимые функции в `tsqueue.cpp`.
   * Скорее всего, вам также потребуется изменить `tsqueue.h`, чтобы добавить нужные поля в `ThreadsafeQueue`.
   * При удалении `// TODO` удалите также и `static_cast<void>()`, которые используются, чтобы заглушить предупреждения компилятора о неиспользуемых переменных.
6. Допишите тесты в `tsqueue_test.cpp`, помеченные как `// TODO` (но не как `// TODO(2)`).
   В них описано, что должно происходить.
   Если возникают вопросы — спрашивайте.
7. Проверьте, что все тесты проходят: скомпилируйте проект и запустите выполняемые файлы `queue_test` и `tsqueue_test`.
   Тесты могут работать довольно медленно, так как пересылка сообщений между потоками — это медленно.
   Даже миллион сообщений может занять несколько десятков секунд.

Если у вас не компилируется, работает медленно или вообще происходит что-то непонятное — не стесняйтесь спрашивать нас, что делать.
Некоторые ошибки может быть трудно отловить самостоятельно в первый раз.

## Требования к корректности решения
### Код
Для решения используется подмножество C++, близкое к языку C.
В частности, мы не используем классы, конструкторы, деструкторы и RAII, а используем структуры
с набором отдельных функций, ручные вызовы деструкторов и прочее веселье.
Чтобы было больше похоже на C: в C++ скорее бы использовались не POSIX Threads,
а `<thread>` из C++11.

### Интерфейс
Контракты функций описаны в комментариях к заголовочным файлам.
Ваша реализация должна полностью соблюдать контракты.

### Тесты
В представленной реализации уже имеется несколько автоматических тестов.
Вам требуется не сломать имеющиеся, добавить свои собственные в местах,
помеченных `// TODO`, а во второй части — дописать тест
`ThreadsafeQueue multithreaded ping-pong` и ещё несколько для новой функции.

### Разумная попытка
Преподаватели в некоторых группах могут требовать сделать "разумную попытку" к определённому сроку.
Под этим понимается:

1. Все места, помеченные `// TODO` или `// TODO(2)`, реализованы.
1. Места в этой папке, не помеченные `// TODO` или `// TODO(2)`, оставлены без изменений.
   Если хочется изменить что-то ещё — напишите, обсудим.
1. Вызов теста `tsqueue_test` добавлен в `.travis.yml`.
1. Все тесты собираются без ошибок и предупреждений.
1. Все тесты корректно отрабатывают.
1. Отсутствуют undefined behavior и утечки памяти.
1. Реализация `threadsafe_queue_wait_and_pop` не нагружает процессов
   при ожидании элемента.

### Блокирующее
Если хотя бы одно из следующих требований не выполняется, вы можете получить не более 30% баллов за задание:

1. Попытка является "разумной" (смотри выше).
1. Отсутствуют заглушения автопроверки стиля и предупреждений компилятора.
1. Отсутствуют race condition.
1. Все проверки на Travis проходят, в частности:
    1. Все тесты собираются без ошибок и предупреждения.
    1. Все тесты корректно отрабатывают.
    1. `valgrind` с `--leak-check=full` на тестах не выдаёт ошибок: например, утечек `Definitely lost` и `Possibly lost`.
       А вот `Still reachable`, порождённые стандартной библиотекой, разрешаются, см. [документацию Valgrind](http://valgrind.org/docs/manual/mc-manual.html#mc-manual.leaks) для деталей.
    1. Файлы не изменяются при форматировании [clang-format](https://clang.llvm.org/docs/ClangFormat.html)
      командой `clang-format -i -style=file src/*` из текущей папки.

## Сдача задания
### Процесс
Задание сдаётся **только** через систему Pull Request в GitHub, см. детальное описание
процесса в папке `common`.
Название Pull Request: `Task04-tsqueue, GroupXX, Фамилия Имя`.

Рекомендуется после создания или обновления Pull Request убедиться, что все проверки на Travis проходят.

Если вы сдаёте с нарушением процесса (например, неверный заголовок Pull Request),
то ваша посылка может быть не проверена, пока вы не исправите формат.

### Сроки
Задание выдано 29.11.2019 (пятница).

Срок сдачи — **13.12.2019 (пятница) 22:59 по Москве**.

В некоторых группах к сроку сдачи требуется лишь сделать посылку,
а доделывать можно потом без последствий; в некоторых может требоваться
исправить все замечания до срока сдачи.
Уточняйте правила у своего преподавателя.

## Система оценки
Задание оценивается в 10 баллов:

| Часть | Корректность | Стиль кода и тестов | Качество тестов |
| ----- | ------------ | ------------------- | --------------- |
| 1 | 2 | 2 | 1 |
| 2 | 2 | 2 | 1 |
| **Итого** | **4** | **4** | **2** |

В каждой группе независимо устанавливаются баллы за посылки, сделанные
после срока сдачи, и за частичное выполнение задания.
Уточняйте правила у своего преподавателя.
